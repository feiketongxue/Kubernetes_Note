# Service

## Service介绍(即 kube-proxy目前支持三种工作模式)

在**kubernetes**中，**pod**是应用程序的载体，我们可以通过**pod**的**ip**来访问应用程序，但是**pod**的**ip**地址不是固定的，这也就意味着不方便直接采用**pod**的**ip**对服务进行访问。

为了解决这个问题，**kubernetes**提供了**Service**资源，**Service**会对提供同一个服务的多个进行聚合，并且提供一个统一的入口地址。通过访问**Service**的入口地址就能访问到后面的**pod**服务。


![20200408194716912](../Images/image-20200408194716912.png)

**Service**在很多情况下只是一个概念，真正起作用的其实是**kube-proxy**服务进程，每个**Node**节点上都运行着一个**kube-proxy**服务进程。当创建**Service**的时候会通过**api-server**向**etcd**写入创建的**service**的信息，而**kube-proxy**会基于监听的机制发现这种**Service**的变动，然后它会将最新的**Service**信息转换成对应的访问规则。

![20200509121254425](../Images/image-20200509121254425.png)

```sh
# 解释
# 10.97.97.97:80 是service提供的访问入口
# 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，
# kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去
# 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点，访问都可以。
[root@node1 ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.97.97.97:80 rr
  -> 10.244.1.39:80               Masq    1      0          0
  -> 10.244.1.40:80               Masq    1      0          0
  -> 10.244.2.33:80               Masq    1      0          0
```

### userspace 模式

**userspace**模式下，kube-proxy会为每一个**Service**创建一个监听端口，发向 **Cluster IP** （service的IP）的请求被**Iptables**规则重定向到**kube-proxy**监听的端口上，**kube-proxy**根据**LB**算法选择一个提供服务的**pod**并和其建立链接，以将请求转发到**pod**上。 该模式下，**kube-proxy**充当了一个四层负责均衡器的角色。由于**kube-proxy**运行在**userspace**中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。

![20200509151424280](../Images/image-20200509151424280.png)

### iptables 模式

**Iptables**模式下，**kube-proxy**为service后端的每个Pod创建对应的**Iptables**规则，直接将发向**Cluster IP**的请求重定向到一个**Pod IP**。 该模式下**kube-proxy**不承担四层负责均衡器的角色，只负责创建**iptables**规则。该模式的优点是较**userspace**模式效率更高，但不能提供灵活的**LB**策略，当后端**pod**不可用时也无法进行重试。

![20200509152947714](../Images/image-20200509152947714.png)

### ipvs 模式

**ipvs**模式和**iptables**类似，**kube-proxy**监控**Pod**的变化并创建相应的**ipvs**规则。**ipvs**相对**iptables**转发效率更高。除此以外，**ipvs**支持更多的**LB**算法。

![20200509153731363](../Images/image-20200509153731363.png)
```sh
# 查看 IPvs 是否生效
[root@master ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn

# 安装 ipvs 模块
# 在 安装集群的时候，就已经安装了

# 此模式必须安装ipvs内核模块，否则会降级为iptables
# 开启ipvs 修改mode: "ipvs"
[root@master ~]# kubectl edit cm kube-proxy -n kube-system
configmap/kube-proxy edited
# 删除 重新加载
[root@master ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system
pod "kube-proxy-cb5v5" deleted
pod "kube-proxy-k2hwq" deleted
pod "kube-proxy-xzswd" deleted

[root@master ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.96.0.1:443 rr
  -> 192.168.1.12:6443            Masq    1      0          0         
TCP  10.96.0.10:53 rr
TCP  10.96.0.10:9153 rr
TCP  10.104.110.143:443 rr
  -> 192.168.1.13:443             Masq    1      0          0         
UDP  10.96.0.10:53 rr

```

## Service 类型

```sh
# Service的资源清单文件
kind: Service           # 资源类型
apiVersion: v1          # 资源版本
metadata:               # 元数据
  name: service         # 资源名称
  namespace: dev        # 命名空间
spec:                   # 描述
  selector:             # 标签选择器，用于确定当前service代理哪些pod
    app: nginx
  type:                 # Service类型，指定service的访问方式
  clusterIP:            # 虚拟服务的ip地址
  sessionAffinity:      # session亲和性，支持ClientIP、None两个选项
  ports:                # 端口信息
    - protocol: TCP 
      port: 3017         # service端口
      targetPort: 5003   # pod端口
      nodePort: 31122    # 主机端口
```
- ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问
- NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务
- LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持
- ExternalName： 把集群外部的服务引入集群内部，直接使用

## Service 使用

### 实验环境准备

在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置app=nginx-pod的标签

```sh
# 创建deployment.yaml
apiVersion: apps/v1
kind: Deployment      
metadata:
  name: pc-deployment
  namespace: dev
spec: 
  replicas: 3
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80
```
```sh
[root@master ~]# kubectl create -f deployment.yaml
deployment.apps/pc-deployment created

# 类似的命令 kubectl get all -n dev -o wide 显示全部
[root@master ~]# kubectl get pods -n dev -o wide --show-labels
NAME                             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES   LABELS
pc-deployment-6696798b78-25z9m   1/1     Running   0          5s    10.244.1.72   node2   <none>           <none>            app=nginx-pod,pod-template-hash=6696798b78
pc-deployment-6696798b78-gtsjp   1/1     Running   0          5s    10.244.1.73   node2   <none>           <none>            app=nginx-pod,pod-template-hash=6696798b78
pc-deployment-6696798b78-t4qmk   1/1     Running   0          5s    10.244.2.78   node1   <none>           <none>            app=nginx-pod,pod-template-hash=6696798b78

# 访问不到，可以重启一下虚拟机
[root@master ~]# curl 10.244.1.72:80
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>

# 修改下三台nginx的index.html页面（三台修改的IP地址不一致）
# kubectl exec -it pc-deployment-6696798b78-25z9m -n dev /bin/sh
# echo "10.244.1.72" > /usr/share/nginx/html/index.html

[root@master ~]# kubectl get pods -n dev -o wide --show-labels
NAME                             READY   STATUS    RESTARTS   AGE     IP            NODE    NOMINATED NODE   READINESS GATES   LABELS
pc-deployment-6696798b78-25z9m   1/1     Running   0          3m34s   10.244.1.72   node2   <none>           <none>            app=nginx-pod,pod-template-hash=6696798b78
pc-deployment-6696798b78-gtsjp   1/1     Running   0          3m34s   10.244.1.73   node2   <none>           <none>            app=nginx-pod,pod-template-hash=6696798b78
pc-deployment-6696798b78-t4qmk   1/1     Running   0          3m34s   10.244.2.78   node1   <none>           <none>            app=nginx-pod,pod-template-hash=6696798b78
[root@master ~]# kubectl exec -it pc-deployment-6696798b78-25z9m -n dev /bin/sh
# echo "10.244.1.72" > /usr/share/nginx/html/index.html
# exit
[root@master ~]# kubectl exec -it pc-deployment-6696798b78-gtsjp -n dev /bin/sh
# echo "10.244.1.73" > /usr/share/nginx/html/index.html
# exit
[root@master ~]# kubectl exec -it pc-deployment-6696798b78-t4qmk -n dev /bin/sh
# echo "10.244.1.78" > /usr/share/nginx/html/index.html
# exit
[root@master ~]# curl 10.244.1.72
10.244.1.72
[root@master ~]# curl 10.244.1.73
10.244.1.73
[root@master ~]# curl 10.244.2.78
10.244.1.78
[root@master ~]#
```

### ClusterIP 类型的 Service
```sh
# 创建 service-clusterip.yaml 文件
apiVersion: v1
kind: Service
metadata:
  name: service-clusterip
  namespace: dev
spec:
  selector:
    app: nginx-pod
  clusterIP: 10.97.97.97    # service的ip地址，如果不写，默认会生成一个
  type: ClusterIP
  ports:
  - port: 80        # Service端口       
    targetPort: 80  # pod端口
```
```sh
# 创建 service
[root@master ~]# vim service-clusterip.yaml
[root@master ~]#  kubectl create -f service-clusterip.yaml
service/service-clusterip created

# 查看 service
[root@master ~]# kubectl get svc -n dev -o wide
NAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR
service-clusterip   ClusterIP   10.97.97.97   <none>        80/TCP    17s   app=nginx-pod

# 查看service的详细信息
# 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口
[root@master ~]# kubectl describe svc service-clusterip -n dev
Name:              service-clusterip
Namespace:         dev
Labels:            <none>
Annotations:       <none>
Selector:          app=nginx-pod
Type:              ClusterIP
IP:                10.97.97.97
Port:              <unset>  80/TCP
TargetPort:        80/TCP
Endpoints:         10.244.1.72:80,10.244.1.73:80,10.244.2.78:80 # 对应的pod的那三个IP
Session Affinity:  None
Events:            <none>

# 查看ipvs的映射规则
[root@master ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.96.0.1:443 rr
  -> 192.168.1.12:6443            Masq    1      1          0         
TCP  10.96.0.10:53 rr
TCP  10.96.0.10:9153 rr
TCP  10.97.97.97:80 rr
  -> 10.244.1.72:80               Masq    1      0          0         
  -> 10.244.1.73:80               Masq    1      0          0         
  -> 10.244.2.78:80               Masq    1      0          0         
TCP  10.104.110.143:443 rr
  -> 192.168.1.13:443             Masq    1      2          0         
UDP  10.96.0.10:53 rr

# 访问10.97.97.97:80 观察效果
[root@master ~]#  curl 10.97.97.97:80
10.244.1.78
[root@master ~]#  curl 10.97.97.97:80
10.244.1.73
[root@master ~]#  curl 10.97.97.97:80
10.244.1.72
[root@master ~]#  curl 10.97.97.97:80
10.244.1.78
```


### Endpoint

**Endpoint** 是**kubernetes**中的一个资源对象，存储在**etcd**中，用来记录一个**service**对应的所有**pod**的访问地址，它是根据**servic**e配置文件中**selector**描述产生的。

一个**Service**由一组**Pod**组成，这些**Pod**通过**Endpoint**暴露出来，**Endpoint**是实现实际服务的端点集合。换句话说，**Service**和**Pod**之间的联系是通过**Endpoint**实现的。

![20200509191917069](../Images/image-20200509191917069.png)
```sh
[root@master ~]# kubectl get endpoints -n dev -o wide
NAME                ENDPOINTS                                      AGE
service-clusterip   10.244.1.72:80,10.244.1.73:80,10.244.2.78:80   7m18s
```


```sh
```
```sh
```


### HeadLiness 类型的 Service
```sh
```


### NodePort 类型的 Service
```sh
```


### LoadBalancer 类型的 Service
```sh
```


### ExternalName 类型的 Service
```sh
```


## Ingress 介绍

> Service对集群之外暴露服务的主要方式有两种:**NotePort** 和 **LoadBalancer**，但是这两种方式，都有一定的缺点：
> - **NotePort** 方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显
> - LB 方式的缺点是每个 service 需要一个 LB，浪费、麻烦，并且需要**kubernetes**之外设备的支持
>
>    基于这种现状，**kubernetes**提供了**Ingress**资源对象，**Ingress**只需要一个**NotePort**或者一个**LB**就可以满足暴露多个**Service**的需求。工作机制大致如下图表示：

## Ingress 使用

### 搭建ingress环境

### 准备 service 和 pod

### Http 代理

### Https 代理

