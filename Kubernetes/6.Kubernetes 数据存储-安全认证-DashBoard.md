# 1. 数据存储

容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes 引入了 Volume 的概念。

Volume 是 Pod 中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes 通过 Volume 实现同一个 Pod 中不同容器之间的数据共享以及数据的持久化存储。Volume 的生命容器不与 Pod 中单个容器的生命周期相关，当容器终止或者重启时，Volume 中的数据也不会丢失。

kubernetes 的 Volume 支持多种类型，比较常见的有下面几个：

- 简单存储：EmptyDir、HostPath、NFS
- 高级存储：PV、PVC
- 配置存储：ConfigMap、Secret

## 1.1 基本存储

### 1.1.1 EmptyDir

EmptyDir 是最基础的 Volume 类型，一个 EmptyDir 就是 Host 上的一个空目录。

EmptyDir 是在Pod被分配到 Node 时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为 kubernetes 会自动分配一个目录，当 Pod 销毁时， EmptyDir 中的数据也会被永久删除。 EmptyDir 用途如下：

- 临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留
- 一个容器需要从另一个容器中获取数据的目录（多容器共享目录）
接下来，通过一个容器之间文件共享的案例来使用一下 EmptyDir。

在一个Pod中准备两个容器 nginx 和 busybox ，然后声明一个 Volume 分别挂在到两个容器的目录中，然后nginx 容器负责向 Volume 中写日志，busybox 中通过命令将日志内容读到控制台。

![1715244234733](../Images/image-20200413174713773.png)

```sh
# 创建 volume-emptydir.yaml 文件

apiVersion: v1
kind: Pod
metadata:
  name: volume-emptydir
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - containerPort: 80
    volumeMounts:  # 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx
    - name: logs-volume
      mountPath: /var/log/nginx
  - name: busybox
    image: busybox:1.30
    command: ["/bin/sh","-c","tail -f /logs/access.log"] # 初始命令，动态读取指定文件中内容
    volumeMounts:  # 将logs-volume 挂在到busybox容器中，对应的目录为 /logs
    - name: logs-volume
      mountPath: /logs
  volumes: # 声明volume， name为logs-volume，类型为emptyDir
  - name: logs-volume
    emptyDir: {}

```

```sh



```
### 1.1.2 HostPath

EmptyDir 中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。

HostPath 就是将 Node 主机中一个实际目录挂在到 Pod 中，以供容器使用，这样的设计就可以保证 Pod 销毁了，但是数据依据可以存在于 Node 主机上。


![1715244234733](../Images/image-20200413214031331.png)

```sh
# 创建 volume-hostpath.yaml 文件
apiVersion: v1
kind: Pod
metadata:
  name: volume-hostpath
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - containerPort: 80
    volumeMounts:
    - name: logs-volume
      mountPath: /var/log/nginx
  - name: busybox
    image: busybox:1.30
    command: ["/bin/sh","-c","tail -f /logs/access.log"]
    volumeMounts:
    - name: logs-volume
      mountPath: /logs
  volumes:
  - name: logs-volume
    hostPath: 
      path: /root/logs
      type: DirectoryOrCreate  # 目录存在就使用，不存在就先创建后使用
```

关于type的值的一点说明：

 - DirectoryOrCreate 目录存在就使用，不存在就先创建后使用
 - Directory   目录必须存在
 - FileOrCreate  文件存在就使用，不存在就先创建后使用
 - File 文件必须存在 
 - Socket  unix套接字必须存在
 - CharDevice  字符设备必须存在
 - BlockDevice 块设备必须存在

```sh
```
### 1.1.3 NFS

HostPath 可以解决数据持久化的问题，但是一旦 Node 节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用 NFS、CIFS。

NFS 是一个网络文件存储系统，可以搭建一台 NFS 服务器，然后将 Pod 中的存储直接连接到NFS系统上，这样的话，无论 Pod 在节点上怎么转移，只要 Node 跟 NFS 的对接没问题，数据就可以成功访问。

![20200413215133559](../Images/image-20200413215133559.png)

1. 
```sh
```
2. 
```sh
```
3. 
```sh
```
4. 
```sh
```

## 1.2 高级存储

前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。

- PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。

- PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。

![20200514194111567](../Images/image-20200514194111567.png)

使用了PV和PVC之后，工作可以得到进一步的细分：

- 存储：存储工程师维护
- PV： kubernetes 管理员维护
- PVC：kubernetes 用户维护

### 1.2.1 PV

```sh
# PV是存储资源的抽象，资源清单文件:
apiVersion: v1  
kind: PersistentVolume
metadata:
  name: pv2
spec:
  nfs: # 存储类型，与底层真正存储对应
  capacity:  # 存储能力，目前只支持存储空间的设置
    storage: 2Gi
  accessModes:  # 访问模式
  storageClassName: # 存储类别
  persistentVolumeReclaimPolicy: # 回收策略
```

PV 的关键配置参数说明：

- 存储类型

    底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异

- 存储能力（capacity）

    目前只支持存储空间的设置( storage=1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置

- 访问模式（accessModes）

    用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：

    1. ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载
    2. ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载
    3. ReadWriteMany（RWX）：读写权限，可以被多个节点挂载

需要注意的是，底层不同的存储类型可能支持的访问模式不同

- 回收策略（persistentVolumeReclaimPolicy）

    当PV不再被使用了之后，对其的处理方式。目前支持三种策略：

    1. Retain （保留） 保留数据，需要管理员手工清理数据
    2. Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*
    3. Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务

需要注意的是，底层不同的存储类型可能支持的回收策略不同

- 存储类别

    PV 可以通过 storageClassName 参数指定一个存储类别

    1. 具有特定类别的PV只能与请求了该类别的PVC进行绑定
    2. 未设定类别的PV则只能与不请求任何类别的PVC进行绑定
- 状态（status）

    一个 PV 的生命周期中，可能会处于4中不同的阶段：

    1. Available（可用）： 表示可用状态，还未被任何 PVC 绑定
    2. Bound（已绑定）： 表示 PV 已经被 PVC 绑定
    3. Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明
    4. Failed（失败）： 表示该 PV 的自动回收失败


> **实验**
> 使用 NFS 作为存储，来演示 PV 的使用，创建 3个 PV ，对应 NFS 中的3个暴露的路径。
1. 准备 NFS 环境
```sh
```
2. 创建 pv.yaml 文件

```sh
```

```sh
```


### 1.2.2 PVC

PVC 是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:

```sh
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc
  namespace: dev
spec:
  accessModes:      # 访问模式
  selector:         # 采用标签对PV选择
  storageClassName: # 存储类别
  resources:        # 请求空间
    requests:
      storage: 5Gi
```

PVC 的关键配置参数说明：

- 访问模式（accessModes）
    用于描述用户应用对存储资源的访问权限

- 选择条件（selector）

    通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选

- 存储类别（storageClassName）

    PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出

- 资源请求（Resources ）

    描述对存储资源的请求

> 实验

1. 创建 pvc.yaml 文件，申请 pv
```sh
```
2. 创建 pods.yaml 文件 , 使用 pv

```sh
```

### 1.2.3 生命周期

> PVC 和 PV 是一一对应的，PV 和 PVC 之间的相互作用遵循以下生命周期：

- 资源供应：管理员手动创建底层存储和PV

- 资源绑定：用户创建 PVC ，kubernetes 负责根据 PVC 的声明去寻找 PV，并绑定

    在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的

- 一旦找到，就将该 PV 与用户定义的 PVC 进行绑定，用户的应用就可以使用这个 PVC 了
- 如果找不到，PVC 则会无限期处于 Pending 状态，直到等到系统管理员创建了一个符合其要求的 PV

    PV一旦绑定到某个PVC上，就会被这个 PVC 独占，不能再与其他PVC进行绑定了

- 资源使用：用户可在 pod 中像 volume 一样使用 pvc

    Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。

- 资源释放：用户删除 pvc 来释放 pv

    当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。

- 资源回收：kubernetes 根据 pv 设置的回收策略进行资源的回收

    对于 PV，管理员可以设定回收策略，用于设置与之绑定的 PVC 释放资源之后如何处理遗留数据的问题。只有 PV 的存储空间完成回收，才能供新的 PVC 绑定和使用


![20200515002806726](../Images/image-20200515002806726.png)
## 1.3 配置存储

### 1.3.1 ConfigMap

### 1.3.2 Secret

# 2. 安全认证

## 2.1 访问控制概述

## 2.2 认证管理

## 2.3 授权管理

## 2.4 准入控制

# 3. DashBoard

## 3.1  部署 Dashboard

## 3.2  使用 DashBoard
